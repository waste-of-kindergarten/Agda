# 自然数

```txt
本章使用的 Unicode 符号：
    ℕ  U+2115  双线体大写 N (\bN)
    →  U+2192  右箭头 (\to, \r, \->)
    ∸  U+2238  点减 (\.-)
    ≡  U+2261  等价于 (\==)
    ⟨  U+27E8  数学左尖括号 (\<)
    ⟩  U+27E9  数学右尖括号 (\>)
    ∎  U+220E  证毕 (\qed)
```

## 自然数 -- 归纳数据类型 (Inductive Datatype)

自然数可以通过以下两条推倒规则(Inference Rules)定义：

    --------
    zero : ℕ 

    m : ℕ 
    -------- 
    suc m : ℕ

以上推导规则描述了：

- 起始步骤(Base Case): `zero` 是一个自然数
- 归纳步骤(Inductive Case): 如果`m`是一个自然数，那么`suc m`也是自然数

推导规则包含写在水平线上的零条或者多条判断(Judgement)，称为假设(Hypothesis);以及写在直线下的一条判断，称为结论(Conclusion).

推导规则可以使用Agda写出。

```agda
 
data ℕ : Set where 
    zero : ℕ
    suc : ℕ → ℕ 
```

其中关键字`data`用于声明归纳定义，`ℕ`是定义的新数据类型的名称，它是一个`Set`(类型)，关键字`where`用于分隔数据类型声明和构造子声明。

`zero`和`suc`是`ℕ`的两个构造子(Successor)，其中`zero`表示零，`suc`表示(任意自然数的)后继。

每个构造子后都由冒号以及相应的类型签名(Signature)跟随，`zero`作为自然数零，类型为`ℕ`，而`suc`表示后继，接受一个自然数作为参数，并返回另一个自然数，因此类型签名为`ℕ → ℕ`。

以上两条推导规则给出了产生自然数的唯一方法，实际上可以验证它满足皮亚诺公理，后续将使用Agda对其进行验证。

> 皮亚诺公理：
> 若三元组$(A,x_0,f)$满足以下条件，则称为一个戴德金-皮亚诺结构：
> 1. $A$是一个集合，$x_0 \in A$，$f : A \rightarrow A$ 
> 2. 不存在一个$t \in A$，使得$f(t) = x_0$
> 3. $f$ 是一个单射，即$\forall s \forall t : f(s) = f(t) \Leftrightarrow s = t$
> 4. 若$B \subset A$，$x_0 \in B$,且$\forall t \in B : f(t) \in B$， 则 $A = B$ 

使用Agda的自然数定义，可以生成自然数的实例，以`7`为例：

```agda 
seven : ℕ 
seven = suc (suc (suc (suc (suc (suc (suc zero))))))
```

## 编译指令

在Agda中的注释(Comment)方法与Haskell相同， 即`--`作为单行注释，`{- ... -}`作为多行注释。在多行注释中，一种例外的注释形式会被识别为编译指令(Pragma) -- `{-# ... #-}`。 

```agda 
 
{-# BUILTIN NATURAL ℕ #-}
```

该指令指示Agda数据类型`ℕ`与自然数对应，因此用户可以将`ℕ`类型简写为`0,1,2,3, ...`。 

## 模块导入

在引入自然数定义之后，就可以进行一些有关自然数事实的推理。在此之前，需要从Agda标准库中导入相等性(Equality)的定义以及用于等式推理的记法：

```agda 
 
import Relation.Binary.PropositionalEquality as Eq 
open Eq using (_≡_;refl)
open Eq.≡-Reasoning using (begin_;_≡⟨⟩_;_∎)
``` 

上述代码中，首行将标准库中定义了相等性的模块导入到了当前作用域(Scope),并命名为`Eq`。第二行打开了`Eq`模块，并使用`using`从句将相等运算符`_≡_`和两个项相等的证据`refl`添加到当前作用域。第三行打开了`Eq`的子模块`≡-Reasoning`(用于等价关系推理)，并将`begin_`，`_≡⟨⟩_`,`_∎`添加到当前作用域，它们分别表示“证明开始”，“等价于”，“证明结束”。

应当注意到，导入的名称中大量使用了下划线。在Agda中，使用下划线标注项(Term)相对于运算符的位置。例如`_≡_`为中缀运算符，而`begin_`为前缀运算符(运算符写在前),`_∎`为后缀运算符(运算符写在后)。

> 注意：括号与分号不允许出现在名称中，因此我们在`using`列表中无需额外空格消除歧义。


## 自然数的运算 -- 递归函数

使用递归(Recursion)可以很容易定义自然数的相关运算。

### 加法

加法使用递归可以定义为两个规则：

    0 + n ≡ n 
    (1 + m) ≡ 1 + (m + n)

使用Agda编写如下：

```agda 
 
_+_ : ℕ → ℕ → ℕ 
zero + n = n
suc m + n = suc (m + n) 
``` 

> 注意: 我们使用等号`=`表示定义，用`≡`表示相等。

加法作为一个中缀运算符，接受两个自然数并返回运算结果，因此类型签名为`ℕ → ℕ → ℕ`。上述定义包含了两个步骤 -- 起始步骤和归纳步骤，与自然数的定义相对应。

起始步骤表明零加任意自然数结果仍然为这个自然数；归纳步骤表明一个数的后继与另一个数相加，结果为这两个数的和的后继。

在加法定义中，构造子出现在等号左侧，我们称为模式匹配(Pattern Matching)。

另外虽然加法定义是递归的，但是较大的数相加是用较小的数相加定义的，这样的定义被称为***良基的(Well founded)***。

下面我们选择加法的实例进行证明，以二加三为例:

```agda
  
_ : 2 + 3 ≡ 5 
_ = -- 根据编译指令，证明过程的等价式子可以替换为注释内容
    begin 
        suc (suc zero) + suc (suc (suc zero)) -- 2 + 3 
    ≡⟨⟩ 
        suc zero + suc (suc (suc (suc zero))) -- 1 + 4
    ≡⟨⟩ 
        zero + suc (suc (suc (suc (suc zero)))) -- 0 + 5
    ≡⟨⟩ 
        suc (suc (suc (suc (suc zero)))) -- 5
    ∎ 
```

整个证明由一个类型签名（首行）和一个提供对应类型的项的绑定(Binding)组成。

在这个证明过程中，首行使用了虚设名称`_`,虚设名称允许用户重复使用，在举例时很便利，除此之外所有名称都只能在模块中定义一次。虚设名称后面为类型签名，亦待证明的命题`2 + 3 ≡ 5`(这是柯里-霍华德同构，后面章节会阐述)。

在给出类型签名（待证明的命题）后，程序给出了相应类型的项进行绑定，亦命题的证明或***证据(Evidence)***(这也是柯里-霍华德同构)。

以数学证明的视角，该证明由等式链组成，等式链由`begin`开始，以`∎`结束，中间由一系列`≡⟨⟩`分隔的向组成。

> 实际上, `begin_`，`_∎`，`≡⟨⟩`只是作为运算符的存在，后面的章节将会详细解析这部分内容。

回到加法的定义，不难看出，不断使用递归定义，可以直接计算出`2 + 3`的结果，因此实际上Agda可以直接化简`2 + 3`为`5`,即命题变成了`5 ≡ 5`。我们可以使用`refl`立刻得出这个显然的结果。

```agda 
 
_ : 2 + 3 ≡ 5 
_ = refl 
``` 

一个值等于其自身的证据写作`refl`。

> 注意: 这里提到的证据等同于证明。

### 乘法

一旦定义了加法，就可以使用递归定义乘法为重复的加法。

    0 * n ≡ 0 
    (1 + m) * n = n + (m * n) 

使用Agda编写如下：

```agda 
 
_*_ : ℕ → ℕ → ℕ 
zero * n = zero 
(suc m) * n = n + (m * n)
``` 

不难看出，这个定义也是良基的，因为较大的数的相乘是用较小的数相乘定义的。

以二乘三为示例：

```agda 
 
_ = 2 * 3 ≡ 6 
_ = 
    begin 
        2 * 3 
    ≡⟨⟩ 
        3 + (1 * 3) 
    ≡⟨⟩ 
        3 + (3 + (0 * 3)) 
    ≡⟨⟩ 
        3 + (3 + 0)
    ≡⟨⟩ 
        3 + 3 
    ≡⟨⟩ 
        6
    ∎
``` 

### 乘方

类似地，可以根据乘法递归定义乘方运算。

    m ^ 0 ≡ 1 
    m ^ (1 + n) ≡ m * (m ^ n)

使用Agda定义： 

```agda 
 
_^_ : ℕ → ℕ → ℕ 
m ^ zero = suc zero 
m ^ suc n = m * (m ^ n)
``` 

### 饱和减法

自然数中不包含负数，因此如果被减数比减数小，为了保证运算的封闭性，我们将其取零。这种针对自然数的减法变种称为***饱和减法(Monus)***。

```agda
 
_∸_ : ℕ → ℕ → ℕ 
m ∸ zero = m 
zero ∸ suc n = zero 
suc m ∸ suc n = m ∸ n 
``` 

饱和减法首次对两个参数使用了模式匹配：

- 考虑第二个参数
    + 如果它是`zero`，结果为第一个参数`m`
    + 如果它是`suc n`，考虑第一个参数
        * 如果它是`zero`，结果为`zero` 
        * 如果它是`suc m`，结果为两个参数的前继的饱和减法，即`m ∸ n`

> 注意： 在定义运算符过程中，应当确保“不重不漏”。

### 优先级

使用***优先级(Precedence)***可以避免书写大量括号，函数运算比任意运算符结合更紧密，拥有最高优先级，因此在运算符和函数混合的表达式中可以去除包裹在函数外的括号，例如`suc m + n`。

在Agda中，中缀运算符的优先级和结合性需要被声明：

```agda 
 
infixl 6 _+_ _∸_
infixl 7 _*_
infixr 8 _^_
``` 

这里加法，饱和减法，乘法都是左结合的，且加法和饱和减法优先级更低；乘方是右结合的，且优先级高于其余三个运算符。

除此之外，用户也可以使用`infix`表示总是需要括号来消除歧义。

## 柯里化

柯里化以Haskell Curry的名字命名，对于接受多参数的函数来说，柯里化视角下允许其接受一个参数，并返回一个接受剩余参数的函数。

在Agda以及Haskell类似的函数式编成语言中，函数箭头是右结合的，而函数应用则是左结合的。

以加法为例：

`ℕ → ℕ → ℕ` 表示 `ℕ → (ℕ → ℕ)`

而

`_+_ a b` 表示 `(_+_ a) b`。

## 更多编译指令

```agda 
 
{-# BUILTIN NATPLUS _+_ #-}
{-# BUILTIN NATTIMES _*_ #-}
{-# BUILTIN NATMINUS _∸_ #-}
``` 

## 标准库

```agda 
-- import Data.Nat using (ℕ; zero; suc; _+_; _*_; _^_; _∸_)
``` 






